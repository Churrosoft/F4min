#!/usr/bin/env python3
# Taken from https://github.com/respeaker/usb_4_mic_array/blob/master/dfu_windows.py
import sys
import time
try:
    import usb.core
    import usb.util
except ImportError as e:
    sys.exit("Pyusb not found.")

class DFU(object):
    TIMEOUT = 120000

    DFU_DETACH = 0
    DFU_DNLOAD = 1
    DFU_UPLOAD = 2
    DFU_GETSTATUS = 3
    DFU_CLRSTATUS = 4
    DFU_GETSTATE = 5
    DFU_ABORT = 6

    DFU_STATUS_DICT = {
        0x00: 'No error condition is present.',
        0x01: 'File is not targeted for use by this device.',
        0x02: 'File is for this device but fails some vendor-specific '
            'verification test.',
        0x03: 'Device is unable to write memory.',
        0x04: 'Memory erase function failed.',
        0x05: 'Memory erase check failed.',
        0x06: 'Program memory function failed.',
        0x07: 'Programmed memory failed verification.',
        0x08: 'Cannot program memory due to received address that is our of '
            'range.',
        0x09: 'Received DFU_DNLOAD with wLength = 0, but device does not think it'
            'has all of the data yet.',
        0x0a: "Device's firmware is corrupt. It cannot return to run-time "
            "(non-DFU) operations.",
        0x0b: 'iString indicates a vendor-specific error.',
        0x0c: 'Device detected unexpected USB reset signaling.',
        0x0d: 'Device detected unexpected power on reset.',
        0x0e: 'Something went wrong, but the device does not know what is was.',
        0x0f: 'Device stalled a unexpected request.',
    }

    def __init__(self):
        openefi = usb.core.find(idVendor=0x1209, idProduct=0xeef1)
        if openefi is not None:
            print("    OpenEFI found, rebooting into bootloader...")
            # try to find the bulk out endpoint...
            configuration = openefi.get_active_configuration()
            iface = None
            for interface in configuration:
                if interface.bInterfaceClass == 0xa:
                    # found the cdc interface
                    iface = interface.bInterfaceNumber
            if iface is None:
                raise ValueError("No CDC interface found!")
            
            usb.util.claim_interface(openefi, iface)
            payload = f = [1, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 74, 13]
            openefi.write(1, bytearray(payload), 12000)
            time.sleep(1)
        self.device = usb.core.find(idVendor=0x1209, idProduct=0xdb42)
        print("    Bootloader found.")
        if not self.device:
            raise ValueError('No DFU device found')
        configuration = self.device.get_active_configuration()

        self.interface = None
        for interface in configuration:
            if interface.bInterfaceClass == 0xFE and interface.bInterfaceSubClass == 0x01:
                self.interface = interface.bInterfaceNumber
        
        if self.interface is None:
            raise ValueError('No intefaces found')

        usb.util.claim_interface(self.device, self.interface)

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    def download(self, firmware):
        """
        Args:
            firmware (file object): the file to download.
        """
        block_size = 64
        block_number = 0
        print('    Downloading... ', end='', flush=False)
        while True:
            data = firmware.read(block_size)
            self._download(block_number, data)
            status = self._get_status()[0]
            if status:
                raise IOError(self.DFU_STATUS_DICT[status])

            block_number += 1

            sys.stdout.write('    Downloading... {0} bytes                        \r'.format(block_number * block_size))
            sys.stdout.flush()

            if not data:
                break

        print('\n    Done.')

    def upload(self, firmware):
        pass

    def _detach(self):
        return self._out_request(self.DFU_DETACH)

    def _download(self, block_number, data):
        return self._out_request(self.DFU_DNLOAD, value=block_number, data=data)


    def _get_status(self):
        data = self._in_request(self.DFU_GETSTATUS, 6)

        status = data[0]
        timeout = data[1] + data[2] << 8 + data[3] << 16
        state = data[4]
        status_description = data[5]         # index of status description in string table

        return status, timeout, state, status_description

    def _clear_status(self):
        return self._out_request(self.DFU_CLRSTATUS)

    def _get_state(self):
        return self._in_request(self.DFU_GETSTATE, 1)[0]

    def _abort(self):
        return self._out_request(self.DFU_ABORT)

    def _out_request(self, request, value=0, data=None):
        return self.device.ctrl_transfer(
            usb.util.CTRL_OUT | usb.util.CTRL_TYPE_CLASS | usb.util.CTRL_RECIPIENT_INTERFACE,
            request, value, self.interface, data, self.TIMEOUT)

    def _in_request(self, request, length):
        return self.device.ctrl_transfer(
            usb.util.CTRL_IN | usb.util.CTRL_TYPE_CLASS | usb.util.CTRL_RECIPIENT_INTERFACE,
            request, 0x0, self.interface, length, self.TIMEOUT)

    def close(self):
        """
        close the interface
        """
        usb.util.dispose_resources(self.device)
#dev = usb.core.find(idVendor=0x1209, idProduct=0xeef1)
dev = DFU()
download = open('./bin/openefi.bin', 'rb')
dev.download(download)

#f.download()